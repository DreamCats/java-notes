面试官：线程的生命周期，讲一下。

我：ok，看图说话

![线程的生命周期-KbDQiX](https://cdn.jsdelivr.net/gh/DreamCats/imgs@main/uPic/线程的生命周期-KbDQiX.png)

- 线程创建之后它将处于`New`（新建）状态，调用 `start()` 方法后开始运行，线程这时候处于 `READY`（可运行，也叫做就绪） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 `RUNNING`（运行） 状态。
- 当线程执行 `wait()`方法之后，线程进入 `WAITING`（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 `TIME_WAITING`(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 `TIMED WAITING` 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。
- 当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 `BLOCKED`（阻塞）状态。
- 线程在执行 Runnable 的` run() `方法结束之后将会进入到 `TERMINATED`（终止） 状态。

## wait/notify和sleep

面试官：wait/notify 和 sleep 方法的异同？

我：ok

相同点：

1. 它们都可以让**线程阻塞**。
2. 它们都可以响应 **interrupt** 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。

不同点：

1. wait 方法必须在 **synchronized** 保护的代码中使用，而 sleep 方法并没有这个要求。
2. 在同步代码中**执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁**。
3. sleep 方法中会要求必须定义一个时间，时间到期后会主动恢复，而对于没有参数的 wait 方法而言，意味着永久等待，直到被中断或被唤醒才能恢复，它并不会主动恢复。
4. **wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法**。